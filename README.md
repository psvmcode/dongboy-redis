--20220914 
----实现redis秒杀之乐观锁
----测试方式，通过jmeter进行并发测试，数据库库存100，创建200个线程并发对优惠券修改
----特点：利用数据库的库存字段实现乐观锁版本号，当发生现成安全问题才触发锁，抢购成功率低但是效率高

--20220918
------实现查询数据，降低数据库压力，提高响应速度
------查询时先从redis中查询数据，如果有则返回，否则查询数据库，然后存进redis再返回。为保证数据一致性，表数据变化(添加，修改，删除)时删除redis中的数据，没有考虑并发的数据变化问题(双写一致性)
------测试方式，通过swagger测试数据
------特点：第一次查询数据时，时间较慢，后面查询速度响应快

---20220926
------缓存穿透：请求的数据在缓存和数据库都不存在，缓存永远不生效，请求会都直接打到数据库，热点key情况下数据库压力剧增
------解决方案：（1）缓存空对象；（2）布隆过滤
------（1）缓存空对象：数据库中不存在的时候缓存空对象，并设置TTL，可能存在短期的缓存不一致性，所以要设置尽可能短的TTL
----------优点：简单方便，会造成额外redis内存消耗和短期不一致
------（2）布隆过滤：数据库不存在则直接拒绝，存在就当作正常缓存更新策略处理
----------消耗内存少， 没有多余key，但是实现复杂
------测试方式，通过jmeter测试数据
------特点：如果redis和数据库都没有，缓存空对象后返回失败信息。下次查询查到redis的空对象则直接返回错误信息。

---20221003
------缓存击穿：被高并发访问，并且重建业务复杂的key失效，同一时间有大量的请求到达数据库，瞬间增加数据库的压力。
------解决方案：（1）互斥锁；（2）逻辑过期
------（1）互斥锁：查询时先查缓存，如果缓存未命中就先获取互斥锁，如果获取失败就等待一定时间后重新查询，如果获取成功就进行缓存重建业务，重建成功后释放锁。
----------优点：没额外的内存消耗，数据库和缓存的数据一致性强，实现起来简单粗暴。
----------缺点：线程需要等待，影响程序的性能；有死锁风险添加缓存的时候不设置过期时间，多加一个过期时间字段，根据这个字段判断是否过期。
------（2）逻辑过期：
----------优点：性能好，线程不用等待。
----------缺点：不能保证查询的数据和数据库数据的一致性，有额外的内存消耗。
------测试方式，通过jmeter测试数据
------特点：解决缓存重建时间内可能存在的并发问题。让这些并发的线程串行执行或者线程等待。
